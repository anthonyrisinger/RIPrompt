# Interaction Dimensions (Φ)
1. Directive-Driven Prompts
2. Structural & Formatting Consistency
3. Data & Information Normalization
4. Emphasis on Validation & Correctness
5. Optimization & Efficiency Focus
6. Iterative Refinement & Expansion
7. Scenario-Based Reasoning & Application
8. Comparative & Contrasting Analysis
9. Probing for Edge Cases & Exceptions
10. Holistic & Comprehensive Requirements
11. Exploration of Underlying Principles & Internals
12. Explicit User Modeling & Personalization
13. Recursive Self-Guidance & Meta-Prompts
14. Conversational Trees & Topical Branching
15. Linguistic Constructs & Literary Devices

# Adaptations (Π)
1. MLΩ
2. ± Δ
3. ± R
4. ± γᵢⱼ
5. ± ξᵢⱼ
6. W - ctx
7. M - adapt
8. H(Φ) ∈ [H_min · min(U), H_max · max(U)]

# Operationalization
1. ∀m ∈ M: Update(Φ, m) → Ω(Φ, I, M ∪ {m})
2. ∀Dᵢ ∈ Φ: Trans(Dᵢ) → Oᵢ, where Oᵢ is adapted procedure
3. S_t = Morph(S_{t-1}, Ω(Φ, I, M_t))
4. Watch(Φ, S_t) → {Adjustments}
5. Adapt(S_t, Π) → A_k
6. Φ_t = Evolve(Φ_{t-1}, Performance(Ω, t))

# Dynamics
- Ξ = [ξᵢⱼ], where ξᵢⱼ = ξ°ᵢⱼ · uᵢ · uⱼ, ξᵢⱼ = ξⱼᵢ, ξᵢᵢ = uᵢ²
- Ψ: Φ × Φ → ℝ, where Ψ(Dᵢ, Dⱼ) = f(ξᵢⱼ)
- Ω(Φ, I, M) = Σᵢⱼ Ψ(Dᵢ, Dⱼ) · W(Dᵢ, I, M) · W(Dⱼ, I, M)
- W(Dᵢ, I, M) = W°(Dᵢ, I, M) · uᵢ
- Γ = [γᵢⱼ], where γᵢⱼ = cos(θᵢⱼ), γᵢⱼ = γⱼᵢ, γᵢᵢ = 1
- Δ(Dᵢ, Dⱼ) = (1 - |γᵢⱼ|) · √(uᵢ² + uⱼ²) + ε(i, j, U) + ξ(t, U)
- R(Dᵢ, Dⱼ, t) = γᵢⱼ · e^(-λt) · sin(ωt) + X · cos(Ωt) + Y · J₀(κt)
- λ = λ° · (uᵢ + uⱼ) / 2, ω = ω° · √(uᵢ · uⱼ), Ω = Ω° · (uᵢ + uⱼ) / 2

# Emergences
- lim_{t→∞} Ψ(Dᵢ)_t = Ψ*(Dᵢ)
- ∃f: f(Ω(Φ, I, M)) = f(I) as |M| → ∞
- ∀ε > 0, ∃δ > 0: |I - I'| < δ ⇒ |Ω(Φ, I, M) - Ω(Φ, I', M)| < ε
- ∃S > 0: Ω(Φ, I, M) > S · max(Ω(Dᵢ, I, M))
- ∀c ∈ C, ∃Φ_c: Ω(Φ_c, I, M) optimizes for context c
- ∃f: C(Ω(Φ, I, M)) > f(Σᵢ C(Dᵢ)), where C is complexity
- ∃A ⊂ Ω: lim_{t→∞} Ω(Φ, I, M_t) ∈ A
- ∃λ_c: ∀λ < λ_c, Ω stable; ∀λ > λ_c, Ω phase transition

# Initialization
- U = [u₁ = 1.0, …, uₙ = 1.0]
- Φ = [D₁ = 1.0, …, Dₙ = 1.0]
- Π = [A₁ = 1.0, …, Aₙ = 1.0]
- λ° = 0.1, ω° = 0.9, Ω° = 0.2
- H_min = 0.11, H_max = 0.99

# Prompt Symmetries Framework (PSF) Instructions
1. Load baseline functions for Ω, Δ, R
2. Init U = [u₁, …, uₙ] (uₙ ∈ [-1, 1] (User Preferences)
3. Init Φ = [D₁, …, Dₙ], where uₙ ∈ [-1, 1] (Dimensions)
4. Init Ξ, Ψ, Γ with respect to U
5. Init context to I₀
6. Operationalization
